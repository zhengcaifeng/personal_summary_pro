1. 谈一下，你对 mvvm 原理的理解

mvc 前端到后台 ，前端就是视图层， 数据是单向的，
对前端用重新划分了一下

传统的 mvc 指的是 用户操作会请求服务端的路由，路由会调用对应的控制器来处理，控制器会获取数据，将结果返回给前端，页面重新渲染

mvvm 传统的前端会将数据手动渲染到页面上，MVVM 模式不需要用户收到操作 dom 元素，将数据绑定到 viewModel 层上，会自动将数据渲染到页面中，视图变化会通知 viewModel 层更新数据，ViewModel 就是 MVVM 模式的桥梁

双向绑定，

2. 响应式数据的原理，
   发布订阅模式和观察者模式

重点：1，Object.defineProperty 2.依赖收集
默认的 Vue 在初始化数据时，会给 data 中的属性使用 Object.defineProperty 重新定义所以属性，当页面取到对应属性时，会进行依赖收集，（收集当前组件的 watcher）如果属性发生变化会通知相关依赖进行更新操作

数据的获取 或设置，都可以可以添加一个拦截，可以增加一些逻辑，依赖收集

3. 数组是如何检测变化的
   使用函数劫持的方式，重写的数组的方法
   Vue 将 data 中的数组，进行原型链重写，指向了自己定义的数组原型方法，这样当调用数组 api 时，可以通知依赖更新，
   如果数组中包含着引用类型，会对数组中的引用类型再次进行监控

原型链重写，当调用数组 api 时，就可以只通知相应的依赖更新

如果监听过，就不会重新监听

4. vue 为何要使用异步渲染
   提高性能，防止一改数据就更新视图 核心方法 nextTick

Vue 是组件级更新

如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染，所以为了性能考虑，Vue 会在本轮数据更新后，再去异步更新视图

当数据更新时，会通知 watcher,他不会马上执行，而是放在一个队列里，如果相同的更改就只保留一个，这个组件都更新完了，统一渲染到视图上

虚拟 dom 是什么
标识成一个对象，
如何创建 dom

虚拟 dom 的优势
Vue 中的 key 到底有什么作用
