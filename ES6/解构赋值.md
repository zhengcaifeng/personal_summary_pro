对象的扩展运算符（...）

解构赋值是浅拷贝

```
let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2
```

将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面
所以不能读取原型上的数据

```
let o1 = { a: 1 };
let o2 = { b: 2 };
o2.__proto__ = o1;
let { ...o3 } = o2;
o3 // { b: 2 }
o3.a // undefined
```

x 是解构赋值，y,z 是扩展运算符的解构赋值，只能读取对象本身的属性

```
const o=Object.create({x:1,y:2})
o.z=3
let {x,...newobj}=o
let {y,z}=newobj
x
y
z
//x:1 y undefind,z:2

```

下面代码报错，ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量 newObj

```
const o=Object.creat({x:1,y:2})
let {x,...{y,z}}=o
```

如果扩展运算符后面是一个空对象，则没有任何效果

```
{...{}, a: 1}
// { a: 1 }
```

如果扩展运算符后面不是对象，则会自动将其转为对象。

```
// 等同于 {...Object(1)}
{...1} // {}
```

数组的解构赋值：

模式匹配

```
let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3
```

```
let [x, y, ...z] = ['a'];
x // "a"
y // undefined
z // []
```

如果解构不成功，变量的值就等于 undefined。
不完全解构也可以

```
let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
```
